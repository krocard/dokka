# Dokka Gradle Plugin DSL 2.0 - WIP

## NOTES

### Some notes regarding checked projects

* two main usages of dokka:
    * generate jar (different formats depending on type of project) with documentation for **MODULE**
    * generate html/gfm with documentation for **ALL MODULES** (aggregated)
* Dokka plugin is configured in all different ways: explicit (different or copy-past configuration in every project),
  via allprojects, via convention plugins
* if there are multiple formats -- configuration is mostly common between formats
* javadoc format is sometime used for maven central even for multiplatform projects
* javadoc.jar is generated from different formats: html, javadoc and even GFM
* almost everywhere the workflow is to use tasks.dokka*.configureEach { dokkaSourceSets.configureEach { ... } }
* changing output dir is a frequent thing to do (it could be because of not knowing where the output is by default)
* small amount of projects uses `sourceLink` or configures it wrong (wrong paths, local or remote)
* A lot of projects uses `perPackage` as `glob-like` (wildcards), not as regex.
  So instead of something like `com\\.example\\.internal` they just write `com.example.internal`,
  it works well (in all cases I think), as `.` in regex is just a match for any character.
  Though, if we start matching with `*` the behavior could be different:
    * `com.example.internal.*` - works acceptably the same for both glob and regex
    * `com.example.internal*` - works differently (glob - fine, regex - match `l` character multiple times)
    * `.*internal.*` - works fine in regex, will not work in glob (because of first symbol is `.`)
    * `*internal*` - incorrect regex, works fine with glob

### Formats, Plugins, Generation, Aggregation

Formats vs. Plugins: the main idea behind them is almost the same, under the hood,
the format is still Dokka Engine Plugin.
The main difference is that during a single Dokka execution we can have only one Format present, and so for each format
we will have different output. For every Format, a separate task should be available.

Dokka Engine Plugin can be applied to two 'phases':

* Generation — generate documentation for sources (per Format)
* Aggregation — aggregate outputs from `Generation` phase from different modules (per Format)

There are multiple types of Dokka Engine Plugins:

* applied to format -> f.e. mathjax/mermaid will generate code which will work only for HTML
* applied to dist -> f.e. versioning (for html only, but could be adapted to other formats) will operate on
  final built dist -> can be used with both aggregated output and single module output
* applied everywhere (to Engine) -> f.e. kotlinAsJava will change signatures, will work in any context/format
* should be applied to both format and dist -> f.e. base (html format),
  styleSheet names should be used during module(format) gen,
  styleSheet files should be used during multi-module(dist) gen

Note: multiModule is currently a plugin, but overall should be part of Dokka Engine itself, and so applying it should be
hidden from user.

Note: current HTML plugin configuration (`DokkaBaseConfiguration`) has some properties like f.e `customAssets`,
which should be provided to both `aggregation` and `generation`, because they are used in different ways.
For `generation` - we just need correct names/paths.
For `aggregation` - we need actual files.

### Configuration sharing

Sharing of configuration possibilities:

1. no sharing, explicit logic in every subproject -> errorprone
2. sharing via `subprojects/allprojects` in `rootProject/some other project` -> not compatible with Isolated Projects
3. sharing via `convention plugins` -> good and fine, but boilerplate for simple projects without buildSrc (or similar)
4. sharing via `settings plugin` -> should work fine, no boilerplate, easy but not very popular;
   configuration is split in multiple places (settings vs root project vs subprojects),
   AGP 8.2 also added `settings plugin`,
   version catalogs don't work with settings plugins

## DSL overview

Formats/plugins configuration omitted and will be described below.

```kotlin
// build.gradle.kts
plugins { id("org.jetbrains.dokka") }
// almost all `.set` calls can be replaced with `=` in Gradle 8.4+
dokka { // DokkaProjectExtension, accessor generated by Gradle
    // those properties available only in root
    dokkaEngineVersion.set("1.9.20")
    offlineMode.set(true)
    failOnWarning.set(true)

    // next block of properties configures generation of documentation for current module
    suppressObviousFunctions.set(true)
    suppressInheritedMembers.set(true)

    includeEmptyPackages.set(true)

    // sourceLinks can be configured in different ways
    sourceLink("https://www.github.com/owner/repository/tree/main")

    externalDocumentationLink("https://example.com/api")
    externalDocumentationLinkToAndroidSdk(enabled = false)
    // etc

    documentedVisibilities.add(DokkaDeclarationVisibility.INTERNAL)
    warnOnUndocumented.set(true)
    includeDeprecated.set(true)
}

```

### Per sourceSet/Package configurations

`DokkaSourceSet` contains most of the properties which are available in root (except for global, like version or offline
mode).
Additionally `DokkaSourceSet` allows to configure some specific properties, like `classpath`, `samples`, etc. Those
properties cannot be configured on root level as they are specific to each sourceSet (f.e jvmMain and jsMain
configuration will be different)

Example of configuring some properties:

```kotlin
dokka {
    // configures all sourceSets, we can conditionaly check something there
    sourceSets.configureEach {
        if (platform == KotlinPlatformType.jvm) {
            // do something here, f.e. add generated files for jvm
            suppressedSourceFiles.from("build/generated/jvm")
            classpath.from("build/something/jvm")
        }

        if (platform == KotlinPlatformType.js) {
            // f.e. suppress js documentation generation
            suppress.set(true)
        }
    }


}
```

In similar way, some properties can be configured per package:

```kotlin
dokka {
    perPackage("*.internal.*") {
        suppress.set(true)
    }
    perPackage("org.example.something") {
        packageDocumentation("This is package documentation")
    }

    // can be configured only in specific sourceSet
    sourceSets.named("jvmMain") {
        perPackage("org.example.something") {
            includeDeprecated.set(true)
        }
    }
}
```

### SourceLink configuration:

```kotlin
dokka {
    // if no `localDirectory` is provided, `rootProject.rootDir` is used, to simplify
    sourceLink("https://www.github.com/owner/repository/tree/main")

    // if complex logic is needed, additional configuration can be provided
    sourceLink("https://www.github.com/owner/repository/tree/main") {
        remoteLineSuffix.set("#line-number")
        localDirectory.set(file("some/folder/here"))
    }

    // sourceLinks can be also configured for sourceSet 
    // f.e if some properties are pointing to generated folders or private sourced 
    sourceSets.named("nativeMain") {
        sourceLink {
            localDirectory.set(file("src/jvmMain"))
            remoteUrl.set(null)
        }
    }
}
```

### ExternalDocumentationLink configuration:

```kotlin
dokka {
    // the simplest case when no package-list url provided
    externalDocumentationLink("kotlinlang.org/api/kotlinx.coroutines")
    // remote package list url
    externalDocumentationLink(
        "kotlinlang.org/api/kotlinx.coroutines",
        "kotlinlang.org/api/kotlinx.coroutines/somewhere/package-list"
    )
    // local package list file
    externalDocumentationLinkFrom(
        "kotlinlang.org/api/kotlinx.coroutines",
        file("build/downloaded/package-list")
    )

    // some predefined useful links, can be enabled or disabled (by default `enabled=true`)
    externalDocumentationLinkToKotlinStdlib(enabled = false)

    // this could be useful also
    externalDocumentationLinkToKotlinxCoroutines()
    // if for some reason, some of the link becomes outdated it can be fixed by lambda
    externalDocumentationLinkToKotlinxSerialization {
        // via remote url
        packageListUrl("kotlinlang.org/api/kotlinx.serialization/somewhere-new/package-list")
        // or via local file
        packageListFrom(file("build/downloaded/package-list"))
    }
}
```

### Includes configuration

There are multiple ways to configure additional documentation for packages/modules: from markdown file,
via text (for simple cases) or via Dokka specific file:

```kotlin
dokka {
    // documentation via text
    // for module
    moduleDocumentation("Please consult website: URL")
    // for package
    packageDocumentation(
        "com.example.delicate",
        "Classes in this package should be used only when developing some low-level things"
    )

    // via file - will use full text from it
    moduleDocumentationFrom(file("README.md"))
    packageDocumentationFrom("com.example.delicate", file("something"))

    // or via Dokka specific format - with `# Module` and `# Package` directives
    includedDocumentation.from(file("module.md"))
}
```

### Generation and Aggregation configuration

We have one DSL, which configures both the generation of documentation for current module,
and aggregation of outputs from included modules. Though, it's possible to use more specific configurations:

```kotlin
dokka {
    // can be set here
    documentedVisibilities.add(DokkaDeclarationVisibility.INTERNAL)
    // or in generation block
    generation {
        documentedVisibilities.add(DokkaDeclarationVisibility.INTERNAL)
    }

    // can be set here
    includeSubprojects()
    // or in aggregation block
    aggregation {
        includeSubprojects()
    }
}
```

Configuration in `generation`/`aggregation` block inherits and overrides' root configuration.

This could be somehow useful mostly for plugins/formats, as f.e. `versioning` plugin should be applied only for
aggregation.
Though, maybe we can leave only `formats/plugins` configuration in those blocks, but this way it better distinguish
properties which affects generation or aggregation. Also, this could help in custom Gradle plugins/convention functions
which want to affect only generation or aggregation. (Single Responsibility Principal)

Generation DSL provides properties which will configure Dokka execution for this module.
Aggregation DSL provides the specify which projects to aggregate, as well some other options:

```kotlin
dokka {
    includeProjects("project1", "project2")

    includeSubprojects(exclude = "some-internal-module")
    // the main difference comparing to `includeSubprojects` is that we include all projects, 
    // even if f.e. dokka aggregation module is located not in root
    includeAllprojects(exclude = "some-internal-module")

    // we can configure multiModule vs collector
    useMultiModule(DokkaMultiModuleFileLayout.NoCopy)
    // or
    useCollector()
}
```

### Plugins/Formats

As Format in Dokka is really just a plugin, configuration for Formats, and Plugins are very similar.
The main difference is that Format means that there will be some produced dist somewhere.
Formats/Plugins can provide Gradle DSL via Gradle plugin (or embedded for out-of-the-box plugins/formats).

Plugins example:

```kotlin
dokka {
    // let's enable embedded plugin
    plugins.kotlinAsJava()
    // or
    plugins.kotlinAsJava {
        enabled.set(true)
    }
    // or
    plugins.kotlinAsJava(enabled = true)
    // or via container DSL
    plugins {
        kotlinAsJava(enabled = true)
    }

    // plugins can provide properties to configure
    plugins {
        versioning {
            currentVersion.set(project.version)
            oldVersionsDirectory.set(dir("build/old-versions"))
        }
    }

    // external plugins can be also added
    // for this plugin Class name and dependency is required
    plugins.custom(
        className = "org.example.SomeDokkaPlugin",
        // dependency from version catalog can be used here 
        dependencyNotation = "org.example.group:some-dokka-plugin:1.2.0"
    ) {
        // setting properties (via DSL) - will be converted to JSON and passed to Dokka Engine
        properties {
            booleanProperty("something", true)
            intProperty("width", 1000)
            // and so on 
        }
    }
    // or if to not use shortcut funciton
    plugins.custom {
        pluginClassName.set("org.example.SomeDokkaPlugin")
        // it's possible to add multiple dependencies if needed
        dependency("org.example.group:some-dokka-plugin:1.2.0")
        properties { /*...*/ }
    }


    // also it's possible to disable some plugin conditionally, even if it configured somewhere before
    plugins.versioning {
        enabled.set(project.gradleProperty("build_enable_versioning").map(String::toBoolean))
    }
}
```

The same configuration is available for Formats. Though, additionally, it's possible to set outputDirectory for format.

```kotlin
dokka {
    formats.html {
        homepageLink.set("https://www.github.com/owner/repository")

        outputDirectory.set(dir("somewhere"))
    }
}

// outputDirectory then can be used anywhere as a property

dokka.formats.html.outputDirectory // DirectoryProperty

```

### Custom Configuration properties

We can provide additional `unsafe` compatibility properties configuration for when DSL was created for
Dokka Gradle Plugin version 2.0.0 (f.e.), in 2.1.0 we removed some property but we still want to execute Dokka 2.0.0
(because of some bug) and we need this property there.
In this case we can provide `unsafe` properties block for plugins, formats and configuration.
We can also hide some `advanced`/EAP properties in this way, f.e. enabledAllTypesPage, as we don't want if it will be
stabilized, so we don't want to update DSL for this.

```kotlin
dokka {
    // for plugins/formats
    plugins.kotlinAsJava {
        customProperties {
            intProperty("oldPropertyName", 123)
        }
    }
    // or for other blocks
    sourceSets.configureEach {
        customProperties {
            intProperty("hm", 1)
        }
    }

    // global/root configuration
    customProperties {
        booleanProperty("enabledAllTypesPage", true)
        // it can be structured
        objectProperty("nested") {
            booleanProperty("someValue", true)
        }
    }
}
```

### Inheriting of configuration

Let's look at the example with all kinds of configurations (plugins/formats are the same):

```kotlin
dokka {

    documentedVisibilities.add(DokkaDeclarationVisibility.INTERNAL)
    formats.html {
        footerMessage.set("global")
    }

    generation {
        formats.html {
            // overrides `global`
            footerMessage.set("generation")
        }
        // overrides INTERNAL
        documentedVisibilities.set(setOf(DokkaDeclarationVisibility.PUBLIC))

        sourceSets.named("jvmMain") {
            // overrides PUBLIC
            documentedVisibilities.set(setOf(DokkaDeclarationVisibility.PRIVATE))

            perPackage("org.internal") {
                // overrides PRIVATE
                documentedVisibilities.set(emptySet())
            }
        }
    }
    aggregation {
        formats.html {
            // overrides `global`
            footerMessage.set("aggregation")
        }
    }
}
```

If values weren't overridden, then it will be inherited from the level above.

## Sharing configuration between projects

Sharing of Dokka execution configuration between projects is rather hard in scope of Gradle Isolated Projects right now.
So here are three variants on how it should be done with new DSL:

### Using `allprojects`

```kotlin
// in root build.gradle.kts
plugins { id("org.jetbrains.dokka") }

// enable aggregation
dokka {
    includeSubprojects()
}

// configures allprojects (not just `subprojects` because it's possible, that some configuration should be shared) 
allprojects {
    plugins.apply("org.jetbrains.dokka")
    dokka {
        // configure all the properties here
    }
}
```

### Using convention plugins

```kotlin
// in convention plugin dokka-conventions.gradle.kts

plugins {
    id("org.jetbrains.dokka")
}

dokka {
    // configure all the properties here
}

// in root build.gradle.kts
plugins { id("dokka-conventions") }

// enable aggregation
dokka {
    includeSubprojects()
}

// we can apply the convention here to all projects if needed
subprojects {
    plugins.apply("dokka-conventions")
}

// or apply in other projects explicitly
// f.e. in projectA/build.gradle.kts
plugins {
    kotlin("jvm") // or any other plugins
    id("dokka-conventions")
}
```

### Using settings plugin

In this case Dokka Gradle Plugin should be applied to `settings.gradle.kts`

```kotlin
// in settings.gradle.kts

plugins {
    id("org.jetbrains.dokka") // or id("org.jetbrains.dokka.settings") depending on possibilities
}

dokka {
    // here we can decide to which projects to apply dokka automatically (DSL is rather WIP)

    // to projects with `org.jetbrains.kotlin.*` plugins applied
    applyDokkaToKotlinProjects()

    // or to explicit list
    applyDokkaToProjects("project1", "project2")

    // or to all excluding
    applyDokkaToAllProjectsExcluding("some-internal-project")


    // configure all the same dokka properties here
    dokkaEngineVersion.set("2.1.1")
    documentedVisibilities.add(DokkaDeclarationVisibility.INTERNAL)
    formats.html {
        footerMessage.set("something")
    }

    // to keep everything in place, we can also setup configuration for multiple modules
    // here is an example of configuring a group of modules by regex
    // so modules like `:feature-x`, `:feature-y` will be configured in the same way
    perModule(".*:feature-.*") {
        documentedVisibilities.add(DokkaDeclarationVisibility.PUBLIC)
    }
}

// in the root project (or any other aggregation project we can then enable aggregation) build.gradle.kts
plugins {
    id("org.jetbrains.dokka")
}

dokka {
    includeSubprojects()
}

```

### Using some custom DSL from our plugin

```kotlin
// in root build.gradle.kts
plugins {
    id("org.jetbrains.dokka")
}

dokka {
    includeSubprojects {
        // this will apply dokka gradle plugin to all included subprojects
        applyDokkaPlugin.set(true)
        // this will make other projects inherit configuration from this
        // TBH: this is very unobvious IMO, because it's rather hard to understand which properties should be inherited
        inheritConfiguration.set(true)
    }

    // configure all the same dokka properties here
}
```

## Javadoc / Maven Central

Javadoc(and not) jar generation use-cases:

* generate `jar` with `javadoc` classifier:
    * content could be of any format (javadoc, html, gfm)
* generate `jar` with `html`/`html-docs` classifier:
    * content contains `html`

javadoc frequent usage in projects:

```kotlin
val javadocJar by tasks.registering(Jar::class) {
    archiveClassifier.set("javadoc")

    // this
    from("$buildDir/dokka/javadoc")
    dependsOn(tasks.named("dokkaJavadoc"))
    // or
    // from(tasks.named("dokkaJavadoc"))
}
```

There are two proposals here:

1. make users register tasks explicitly, providing helper function. In this case, user will need to manually add this
   jar to publication.
   ```kotlin
   // in build.gradle.kts where dokka plugin is applied
   // for *-javadoc.jar with HTML format
   registerDokkaJavadocJarTask(dokka.formats.html)
   // or *-javadoc.jar with javadoc format - this could be defaulted for JVM project, but wrong for KMP projects
   registerDokkaJavadocJarTask(dokka.formats.javadoc)
   // it will be also possible to change classifier
   registerDokkaJavadocJarTask(format = dokka.formats.html, classifier = "html-docs")
   ```
2. do it almost automatically similar to how KGP does with sources. In this case, we will automatically add this jar to
   publication:
   ```kotlin
   kotlin {
       // in KMP plugin, KGP provides such DSL, which aligns with java gradle DSL
       withSourcesJar(publish = true)
       
       // we can provide an extension here (theoretically it can be enabled by default when dokka and kotlin plugins are applied) 
       withDokkaJavadocJar(dokka.formats.html)
       // or other jar
       withDokkaJar(format = dokka.formats.html, classifier = "html-docs")
       
       // just in case, may be KGP will someday provide just something like this:
       withKdocJar(publish = true) // which will handle javadoc.jar case and machine readable format
   }
   // example of the same thing in java plugin DSL
   java {
       withSourcesJar()
       withJavadocJar()
   }
   ```

## Tasks

* dokkaGenerate - will generate documentation for all formats / all aggregations
    * dokkaGenerateHtml - will generate documentation for all HTML things
        * dokkaGenerateModuleHtml - will generate documentation for this module only (f.e for javadoc)
        * dokkaGenerateModulePartialHtml - will generate documentation for this module only if it's used for aggregation
        * dokkaGenerateAggregatedHtml - will generate aggregated HTML from included projects
    * etc., dokkaGenerateJavadoc (or any other format)
* dokkaGenerateModuleHtmlJar - jar for module html
* dokkaGenerateAggregatedHtmlJar - TODO is it needed?
* replace `Html` with any other format name for other formats

TODO:

* task types are not yet defined

## Technical notes

* better to depend on `dokka-core` only in workers runtime — not exposing any types from there and not using them in
  Gradle plugin itself - this way we will be able to build `dokka-core` and other modules with any Kotlin version.
  As well, there will be no issues when running with a different Dokka Engine version
* settings vs. project plugin name — can it be the same?
* maybe Gradle will provide some better APIs in the scope of Isolated Projects to share configuration?
* Dumping a Dokka execution result to JSON could allow simplifying some things regarding configuration of some
  plugins/formats (f.e by configuring HTML configuration in one place?)
* sharing configuration in included builds is possible only via convention plugins
* Relative paths should be used for all properties to work with remote build-cache (user still should be able to provide
  absolute paths)
* storing JSON configuration in some folder during/before/after execution can be useful
* no URL usage
* need to log where documentation was generated
* sourceFiles instead of sourceRoots—align with KGP/AGP API
* configuration classes (and may be some others) most likely should be annotated with `@Nested` and be just containers
* packageList should be downloaded via Gradle and not inside Dokka
* most likely we may need to change some types in `dokka-core` configuration (like URL type, or some other properties)
* more flexibility on how URLs are generated comparing to what is shown to the user
* investigate possibility to use dependencies for documentation resolve (https://github.com/Kotlin/dokka/issues/463)
    * local case should be rather easy (get sources of other modules)
    * remote case is harder as we need to download `sources.jar`, but it should be rather straightforward
*

## Other notes

What to do when a project configured for both `generation` and `aggregation`. F.e following project structure:

```
root/
  build.gradle.kts
  setings.gradle.kts
  src/main/kotlin/RootClass.kt
  subproject-a/
    build.gradle.kts
    src/main/kotlin/AClass.kt
  subproject-b/
    build.gradle.kts
    src/main/kotlin/BClass.kt
```

Should dokka generate documentation for two (subproject-a + subproject-b) or three (additionally for root) modules?
Should we support such cases or just throw?
What other possibilities do we have?

Do we need to be able to provide multiple HTML outputs: f.e Android library with multiple flavors?
Imaging project with 3 sourceSets:

* main — shared sourceSet for both flavors
* paid - flavor 1
* free - flavor 2

In this case, user might want to provide 2 HTML outputs: for free and paid version.

We can try to support this via DSL like this (KGP doesn't support flavors):

```kotlin
dokka {
    flavor("free") {
        formats.html {
            // configure here
            footerMessage.set("free")
        }
        sourceSets.named("paid") {
            enabled.set(false)
        }
    }
    flavor("paid") {
        formats.html {
            // configure here
            footerMessage.set("paid")
        }
        sourceSets.named("free") {
            enabled.set(false)
        }
    }
}
```

Recheck properties default values

## Migration

TODO points:

* Check how it will affect https://github.com/vanniktech/gradle-maven-publish-plugin
* Check that we can aggregate documentation from included builds
* Migration from dokkatoo would be nice

Some kind of proposed Migration (2.0.0 = Dokka Gradle Plugin 2 release version):

* 2.0.0 — 2 DSLs are in 1 plugin - old API deprecated with warning, deprecated tasks start to show warning on execution
* 2.1.0 — same - old API deprecated with error (but still there will be no red code),
  deprecated tasks start to fail with error on execution (if f.e. deprecation is suppressed, or groovy is used)
* 2.2.0 — old API removed, old tasks removed

## API Reference

Code is located in `dokka-runners/runner-gradle-plugin/src/main/kotlin/org/jetbrains/dokka/gradle`
Generated HTML of this API with dokka: 
